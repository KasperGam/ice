/*******************************************************************************
 * Copyright (c) 2014 UT-Battelle, LLC.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Initial API and implementation and/or initial documentation - Jay Jay Billings,
 *   Jordan H. Deyton, Dasha Gorin, Alexander J. McCaskey, Taylor Patterson,
 *   Claire Saunders, Matthew Wang, Anna Wojtowicz
 *******************************************************************************/
package org.eclipse.ice.io.ips;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.net.InetAddress;
import java.net.UnknownHostException;

import org.eclipse.ice.datastructures.form.Entry;
import org.eclipse.ice.datastructures.form.DataComponent;
import org.eclipse.ice.datastructures.form.MasterDetailsComponent;
import org.eclipse.ice.datastructures.form.TableComponent;
import org.eclipse.ice.datastructures.updateableComposite.Component;

public class IPSWriter {

	/**
	 * Nullary constructor
	 */
	public IPSWriter() {
		super();
	}
	
	/**
	 * Writes out an INI file from the given DataComponents to an outputFile.
	 * 
	 * @param components
	 *           An ArrayList of DataComponents holding the data for the INI file.
	 * @param outputFile
	 *           The file to write to.
	 * @throws FileNotFoundException
	 *           Thrown when the output file could not be found.
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	public void writeINIFile(ArrayList<Component> components, File outputFile)
			throws FileNotFoundException, IOException  {
		if (components != null && components.size() > 3 && outputFile.isFile()) {
			OutputStream stream = new FileOutputStream(outputFile);
			int numComponents = components.size();
			
			writeICEHeader(stream);
			writeGlobalConfig((TableComponent) components.get(1), stream);
			writePortsTable((TableComponent) components.get(2), stream);
			MasterDetailsComponent masterDetails = (MasterDetailsComponent) components.get(3);
			for ( int i = 0; i < masterDetails.numberOfMasters(); i++) {
				writeComponent((DataComponent) masterDetails.getDetailsAtIndex(i), stream);
			}
			writeTimeLoopData((DataComponent) components.get(0), stream);
			stream.close();
		}
		
	}

	
	/**
	 * Writes an ICE header at the top of the INI file, providing the date, time
	 * and hostname where the file was generated.
	 * 
	 * @param stream
	 *            The OutputStream to write to
	 * @throws UnknownHostException
	 *             Thrown when the host cannot be resolved
	 * @throws IOException
	 *             Thrown when writing to OutputStream fails
	 */
	private void writeICEHeader(OutputStream stream)
			throws UnknownHostException, IOException {
		
		DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
		String date = dateFormat.format(new Date());
		String user = System.getProperty("user.name");
		String hostname = "";
		hostname = InetAddress.getLocalHost().getHostName();

		String iceHeader = String.format(
				"# *** IPS INI file generated by ICE ***\n"
						+ "#  (Eclipse Integrated Computational Environment)\n"
						+ "#\n" + "#  Created:   %-30s\n"
						+ "#  User:      %-30s\n" + "#  Hostname:  %-30s\n\n\n",
				date, user, hostname);

		// Write to the output stream
		byte[] byteArray = iceHeader.getBytes();
		stream.write(byteArray);

		return;
		
	}

	/**
	 * Takes the Global Configuration DataComponent and extracts each 
	 * of the parameters and writes the contents to the specified
	 * OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing the global configuration
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writeGlobalConfig(TableComponent component, OutputStream stream) 
			throws IOException {
		
		// Local Declarations
		String configString = "";
		ArrayList<Entry> row;
		byte[] byteArray;
		
		// Build the output by going through each row
		for (int i = 0; i < component.numberOfRows(); i++) {
			row = component.getRow(i);
			configString += row.get(0).getValue().trim() + "=" + row.get(1).getValue().trim() + "\n";
		}
		configString += "\n";
		
		// Write it out
		byteArray = configString.getBytes();
		stream.write(byteArray);
	}

	/**
	 * Takes the Ports Table DataComponent and extracts each of the
	 * ports implementation details and writes the contents to the
	 * specified OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing the ports table
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writePortsTable(TableComponent component, OutputStream stream) 
			throws IOException {
		
		// Local Declarations
		String configString = "[PORTS]\n\tNAMES = ";
		ArrayList<Entry> row;
		byte[] byteArray;
		
		// Build the output by going through each row
		for (int i = 0; i < component.numberOfRows(); i++) {
			row = component.getRow(i);
			configString += row.get(0).getValue().trim() + " ";
		}
		configString += "\n\n";
		
		for (int i = 0; i < component.numberOfRows(); i++) {
			row = component.getRow(i);
			configString += "\t[[" + row.get(0).getValue().trim() + "]]\n\t\t"
					+ "IMPLEMENTATION = " + row.get(1).getValue().trim() + "\n";
		}
		configString += "\n";
		
		// Write it out
		byteArray = configString.getBytes();
		stream.write(byteArray);
		
	}

	/**
	 * Takes a Port Entry DataComponent and extracts each of the
	 * port's implementation details and writes the contents to the
	 * specified OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing a port entry
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writeComponent(DataComponent component, OutputStream stream)
			throws IOException {
		// Get the port name and the entries
		String currLine = "[" + component.getName() + "]\n";
		ArrayList<Entry> portParams = component.retrieveAllEntries(); 
		
		// Write the port header
		byte[] byteArray = currLine.getBytes();
		stream.write(byteArray);
		
		// Write each of the port parameters
		for ( Entry param : portParams ) {
			// Write the port header
			currLine = "\t" + param.getName().trim() + " = ";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
			
			// Write the port implementation
			currLine = param.getValue().trim() + "\n";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
		}
		
		// Write a blank line for a spacer
		currLine = "\n";
		byteArray = currLine.getBytes();
		stream.write(byteArray);
	}

	/**
	 * Takes the Time Loop DataComponent and extracts each of the
	 * time loop's implementation details and writes the contents to the
	 * specified OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing time loop data
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writeTimeLoopData(DataComponent component, OutputStream stream) 
			throws IOException {
		// Get the port name and the entries
		String currLine = "[TIME_LOOP]\n";
		ArrayList<Entry> timeLoopParams = component.retrieveAllEntries(); 
		
		// Write the port header
		byte[] byteArray = currLine.getBytes();
		stream.write(byteArray);
		
		// Write each of the port parameters
		for ( Entry param : timeLoopParams ) {
			// Write the port header
			currLine = "\t" + param.getName().trim() + " = ";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
			
			// Write the port implementation
			currLine = param.getValue().trim() + "\n";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
		}
		
		// Write out a final blank line
		currLine = "\n";
		byteArray = currLine.getBytes();
		stream.write(byteArray);

	}

}
